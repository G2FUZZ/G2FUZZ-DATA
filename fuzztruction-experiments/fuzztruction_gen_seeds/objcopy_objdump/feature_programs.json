{"**Header Structure**": "import os\nimport struct\n\ndef create_coff_file(file_path):\n    # Ensure the target directory exists\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    \n    # COFF File Header Fields (placeholders for this example)\n    machine = 0x14C  # Machine type (x86)\n    numberOfSections = 1  # Number of sections\n    timeDateStamp = 0  # Time & date stamp\n    pointerToSymbolTable = 0  # Pointer to symbol table (deprecated)\n    numberOfSymbols = 0  # Number of symbols (deprecated)\n    sizeOfOptionalHeader = 0  # Size of optional header\n    characteristics = 0x102  # Characteristics (e.g., executable image)\n    \n    # Packing the header into bytes\n    coff_header = struct.pack('<HHIIIHH', machine, numberOfSections, timeDateStamp,\n                              pointerToSymbolTable, numberOfSymbols, sizeOfOptionalHeader, characteristics)\n    \n    # Writing the header to the file\n    with open(file_path, 'wb') as f:\n        f.write(coff_header)\n        \n    print(f'COFF file created at: {file_path}')\n\n# Specify the path for the new COFF file\ncoff_file_path = './tmp/sample.coff'\n\n# Create the COFF file\ncreate_coff_file(coff_file_path)", "**Section Headers**": "import os\nimport struct\n\ndef create_coff_file(filename):\n    # Ensure the tmp directory exists\n    os.makedirs(\"./tmp\", exist_ok=True)\n    filepath = os.path.join(\"./tmp\", filename)\n\n    # Open file in binary write mode\n    with open(filepath, \"wb\") as f:\n        # COFF File Header (simplified)\n        # Just for demonstration, not accurate for real COFF structure\n        f.write(struct.pack('<H', 0x014C))  # Machine (Intel 386)\n        f.write(struct.pack('<H', 1))       # Number of Sections\n        f.write(struct.pack('<L', 0))       # Time Date Stamp\n        f.write(struct.pack('<L', 0))       # Pointer to Symbol Table (unused here)\n        f.write(struct.pack('<L', 0))       # Number of Symbols (unused here)\n        f.write(struct.pack('<H', 0))       # Size of Optional Header (no optional header for simplicity)\n        f.write(struct.pack('<H', 0))       # Characteristics\n\n        # Section Header (simplified)\n        # Again, simplified and not fully representative of a real COFF section header\n        section_name = \".text\".ljust(8, '\\x00')  # Section name (padded to 8 bytes)\n        f.write(section_name.encode('utf-8'))   # Name\n        f.write(struct.pack('<L', 0x1000))      # Virtual Size\n        f.write(struct.pack('<L', 0x1000))      # Virtual Address\n        f.write(struct.pack('<L', 0x200))       # Size Of Raw Data\n        f.write(struct.pack('<L', 0x200))       # Pointer To Raw Data\n        f.write(struct.pack('<L', 0))           # Pointer To Relocations\n        f.write(struct.pack('<L', 0))           # Pointer To Linenumbers\n        f.write(struct.pack('<H', 0))           # Number Of Relocations\n        f.write(struct.pack('<H', 0))           # Number Of Linenumbers\n        f.write(struct.pack('<L', 0x60000020))  # Characteristics (code section)\n\n    print(f\"COFF file '{filename}' has been created in './tmp/' directory.\")\n\n# Replace 'example.coff' with your desired file name\ncreate_coff_file(\"example.coff\")", "**Symbol Table**": "import os\n\n# Ensure the ./tmp/ directory exists\noutput_dir = \"./tmp/\"\nos.makedirs(output_dir, exist_ok=True)\n\n# Path to the output 'coff' file\noutput_file_path = os.path.join(output_dir, \"example.coff\")\n\n# Dummy symbol table entries\nsymbol_table = [\n    {\"name\": \"main\", \"type\": \"function\", \"address\": \"0x1000\"},\n    {\"name\": \"helper\", \"type\": \"function\", \"address\": \"0x1050\"},\n    {\"name\": \"data\", \"type\": \"variable\", \"address\": \"0x2000\"},\n]\n\n# Writing the dummy symbol table to a file\nwith open(output_file_path, \"w\") as file:\n    file.write(\"Symbol Table\\n\")\n    file.write(\"=============\\n\")\n    for symbol in symbol_table:\n        file.write(f\"Name: {symbol['name']}, Type: {symbol['type']}, Address: {symbol['address']}\\n\")\n\nprint(f\"COFF file with dummy symbol table created at: {output_file_path}\")", "**Relocation Information**": "import os\nfrom struct import pack\n\n# Ensure the tmp directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Function to create a simple COFF file with relocation information\ndef create_coff_with_relocation(filename):\n    # COFF Header\n    # For simplicity, many fields will be set to zero or simple values, as this example\n    # is not focusing on creating a fully functional COFF file but to demonstrate the inclusion\n    # of relocation information.\n    header = pack(\n        '<HHLLLHH',\n        0x14C,  # Machine type (x86)\n        1,      # Number of sections\n        0,      # TimeDateStamp\n        0,      # PointerToSymbolTable (set later)\n        0,      # NumberOfSymbols (set later)\n        0x20,   # SizeOfOptionalHeader\n        0       # Characteristics\n    )\n\n    # Section Header\n    section_header = pack(\n        '<8sLLLLLLHHI',\n        b'.data\\0\\0',  # Name\n        0,             # VirtualSize\n        0,             # VirtualAddress\n        8,             # SizeOfRawData\n        0x80,          # PointerToRawData (set after headers)\n        0x80 + 8,      # PointerToRelocations\n        0,             # PointerToLinenumbers\n        1,             # NumberOfRelocations\n        0,             # NumberOfLinenumbers\n        0x40           # Characteristics (contains initialized data)\n    )\n\n    # Relocation entry\n    # This part simulates the relocation information.\n    relocation_entry = pack(\n        '<LLH',\n        0,      # VirtualAddress\n        0,      # SymbolTableIndex\n        0x14    # Type\n    )\n\n    # Simulated data section\n    # In a real COFF file, this would be the compiled code or data.\n    data_section = b'\\x00' * 8\n\n    # Combine all parts\n    coff_file_content = header + section_header + data_section + relocation_entry\n\n    # Write the COFF file\n    with open(filename, 'wb') as f:\n        f.write(coff_file_content)\n\n# Create a COFF file with relocation information\ncreate_coff_with_relocation('./tmp/sample.coff')", "**Debugging Information**": "import os\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Define the file path\nfile_path = './tmp/debug_info.coff'\n\n# Debugging information to be included\ndebug_info = \"\"\"\nDebugging Information:\n- Filename: example.c\n- Line Numbers: 23, 42, 56\n- Symbols: main, computeValue, displayResult\n\"\"\"\n\n# Write the debugging information to the file\nwith open(file_path, 'w') as file:\n    file.write(debug_info)\n\nprint(f'Debugging information written to {file_path}')", "**Endian Specificity**": "import os\nimport struct\n\ndef create_coff_file(file_path, is_big_endian):\n    # COFF file header structure (simplified):\n    #   - Machine (2 bytes)\n    #   - Number of Sections (2 bytes)\n    #   - Time Date Stamp (4 bytes)\n    #   - Pointer to Symbol Table (4 bytes)\n    #   - Number of Symbols (4 bytes)\n    #   - Size of Optional Header (2 bytes)\n    #   - Characteristics (2 bytes)\n    \n    # Choose endian format\n    endian_format = '>' if is_big_endian else '<'  # '>' for big-endian, '<' for little-endian\n    \n    # Example values for a minimal COFF header (adjust according to actual needs)\n    machine_type = 0x14C  # Example: 0x14C for x86\n    num_of_sections = 0\n    time_date_stamp = 0\n    ptr_to_sym_tab = 0\n    num_of_symbols = 0\n    size_of_opt_header = 0\n    characteristics = 0x102  # Example: Relocatable, Executable, Line nums stripped, 32 bit machine\n    \n    # Pack the header into binary format\n    header_format = f'{endian_format}HHLLLHH'\n    header_data = struct.pack(header_format, machine_type, num_of_sections, time_date_stamp,\n                              ptr_to_sym_tab, num_of_symbols, size_of_opt_header, characteristics)\n    \n    # Ensure the `./tmp/` directory exists\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    \n    # Write the binary data to the COFF file\n    with open(file_path, 'wb') as f:\n        f.write(header_data)\n\n# Example usage\ncreate_coff_file('./tmp/example_coff_little_endian.coff', is_big_endian=False)\ncreate_coff_file('./tmp/example_coff_big_endian.coff', is_big_endian=True)", "**Optional Header**": "import os\nimport struct\n\n# Create the tmp directory if it doesn't exist\nos.makedirs('./tmp/', exist_ok=True)\n\n# Path to the .coff file\nfile_path = './tmp/example.coff'\n\n# Simulating some optional header values (for demonstration purposes only)\nentry_point_address = 0x1000\nstack_size = 0x100000\nheap_size = 0x100000\n\n# Open the file in binary write mode\nwith open(file_path, 'wb') as coff_file:\n    # Writing a mock optional header to the .coff file\n    # This is a simplification and does not adhere to the actual COFF format\n    # Format: I = unsigned int (4 bytes each)\n    # Writing entry point address, stack size, and heap size\n    coff_file.write(struct.pack('III', entry_point_address, stack_size, heap_size))\n\nprint(f'Mock COFF file with optional header created at: {file_path}')"}