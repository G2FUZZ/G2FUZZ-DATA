{"Lossless Compression": "from PIL import Image, ImageDraw\n\n# Create an image with solid colors\ndef create_image_with_compression_demo():\n    # Image dimensions\n    width, height = 800, 600\n    \n    # Create a new image with a white background\n    image = Image.new('RGB', (width, height), 'white')\n    draw = ImageDraw.Draw(image)\n    \n    # Create rectangles of solid colors\n    colors = ['red', 'green', 'blue', 'yellow', 'black']\n    rectangle_width = width // len(colors)\n    for i, color in enumerate(colors):\n        draw.rectangle([i * rectangle_width, 0, (i + 1) * rectangle_width, height], fill=color)\n    \n    # Save the image using PNG format\n    output_path = './tmp/lossless_compression_demo.png'\n    image.save(output_path, 'PNG')\n\n# Ensure the ./tmp/ folder exists\nimport os\nif not os.path.exists('./tmp/'):\n    os.makedirs('./tmp/')\n\ncreate_image_with_compression_demo()", "Transparency Support": "from PIL import Image, ImageDraw\n\n# Ensure the ./tmp/ directory exists\nimport os\nif not os.path.exists('./tmp/'):\n    os.makedirs('./tmp/')\n\n# Create an image with transparent background\nwidth, height = 400, 400\nimage = Image.new(\"RGBA\", (width, height), (255, 0, 0, 0))\n\n# Initialize the drawing context\ndraw = ImageDraw.Draw(image)\n\n# Draw a semi-transparent red circle in the center\ncircle_radius = 100\ncircle_center = (width // 2, height // 2)\ndraw.ellipse([circle_center[0] - circle_radius, circle_center[1] - circle_radius,\n              circle_center[0] + circle_radius, circle_center[1] + circle_radius], \n             fill=(255, 0, 0, 128))  # Semi-transparent red\n\n# Save the image with transparency\nimage.save('./tmp/transparent_circle.png')", "Color Depth": "from PIL import Image, ImageDraw\n\n# Ensure the ./tmp/ directory exists\nimport os\nif not os.path.exists('./tmp/'):\n    os.makedirs('./tmp/')\n\n# Function to create a gradient image\ndef create_gradient(width, height, color1, color2):\n    base = Image.new('RGB', (width, height), color1)\n    top = Image.new('RGB', (width, height), color2)\n    mask = Image.new('L', (width, height))\n    mask_data = []\n    for y in range(height):\n        mask_data.extend([int(255 * (y / height))] * width)\n    mask.putdata(mask_data)\n    base.paste(top, (0, 0), mask)\n    return base\n\n# Create a 24-bit truecolor gradient image\nimage_24bit = create_gradient(256, 256, (255, 0, 0), (0, 0, 255))\nimage_24bit.save('./tmp/24bit_truecolor.png')\n\n# Create a high-quality image to represent 48-bit color depth\n# Note: This will still be saved as a 24-bit PNG but is meant to demonstrate a high-quality color image\nimage_48bit_like = create_gradient(256, 256, (0, 255, 0), (255, 255, 0))\nimage_48bit_like.save('./tmp/48bit_like_truecolor.png')\n\n# Create a grayscale image\nimage_grayscale = Image.new('L', (256, 256))\nfor x in range(256):\n    for y in range(256):\n        image_grayscale.putpixel((x, y), int(x/256*255))\nimage_grayscale.save('./tmp/grayscale.png')", "Interlacing": "from PIL import Image\nimport os\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create a new image with RGB channels, 100x100 pixels\nimage = Image.new('RGB', (100, 100), color = 'blue')\n\n# Save the image with interlacing (passing the 'progressive' argument as True)\nimage.save('./tmp/interlaced_image.png', 'PNG', progressive=True)", "Gamma Correction": "import numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\n# Ensure the ./tmp/ directory exists\noutput_dir = './tmp/'\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n\n# Create an image with varying brightness\nwidth, height = 256, 256\nimage = np.zeros((height, width), dtype=np.uint8)\n\n# Create a gradient from left (black) to right (white)\nfor x in range(width):\n    image[:, x] = x\n\n# Apply gamma correction\ngamma = 0.5  # Gamma less than 1 - light areas will be emphasized\nimage_gamma_corrected = np.array(255 * (image / 255) ** gamma, dtype='uint8')\n\n# Save the original and gamma-corrected images\nplt.imsave(f'{output_dir}original.png', image, cmap='gray')\nplt.imsave(f'{output_dir}gamma_corrected.png', image_gamma_corrected, cmap='gray')", "Color Management": "import os\nfrom PIL import Image\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create a simple gradient image\nwidth, height = 600, 400\nimage = Image.new(\"RGB\", (width, height))\nfor x in range(width):\n    for y in range(height):\n        image.putpixel((x, y), (int(255 * (x / width)), int(255 * (y / height)), 112))\n\n# Save the image without embedding an ICC profile\nimage.save('./tmp/gradient_without_icc.png', 'PNG')\n\nprint(\"PNG file saved.\")", "Metadata Storage": "from PIL import Image, PngImagePlugin\nimport os\nfrom datetime import datetime\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create a new image with RGB mode and white background\nimage = Image.new('RGB', (640, 480), color='white')\n\n# Prepare metadata\nmeta_info = PngImagePlugin.PngInfo()\nmeta_info.add_text('Copyright', 'Copyright 2023 by Example')\nmeta_info.add_text('Comment', 'Generated for demonstrating metadata storage in PNG files.')\nmeta_info.add_text('Creation Time', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n\n# Save the image with metadata\nimage.save('./tmp/metadata_example.png', 'PNG', pnginfo=meta_info)\n\nprint('Image with metadata saved to ./tmp/metadata_example.png')", "Filter Algorithms": "import os\nimport numpy as np\nfrom PIL import Image\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Generate a horizontal gradient image\nwidth, height = 256, 256\nimage_data = np.zeros((height, width, 3), dtype=np.uint8)\n\n# Create gradient\nfor x in range(width):\n    for y in range(height):\n        image_data[y, x] = [x, x, x]  # RGB channels\n\n# Save the image\nimg = Image.fromarray(image_data, 'RGB')\nimg.save(f'./tmp/gradient.png', format='PNG', compress_level=9)\n\nprint(\"Image saved.\")", "Robustness to File Corruption": "import os\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Ensure the ./tmp/ directory exists\noutput_dir = \"./tmp/\"\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n\n# Generate an image to demonstrate PNG's robustness to file corruption\n# Using a basic plot for simplicity\n\n# Creating a simple plot\nplt.figure(figsize=(6, 4))\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\nplt.plot(x, y, label='Sin(x)')\nplt.title('Robustness to File Corruption: PNG Format')\nplt.xlabel('X axis')\nplt.ylabel('Y axis')\nplt.legend()\n\n# Save the plot as a PNG file\noutput_path = os.path.join(output_dir, 'robustness_to_file_corruption.png')\nplt.savefig(output_path)\nplt.close()\n\nprint(f\"Image saved at: {output_path}\")", "Palette-based Images": "from PIL import Image, ImageDraw\n\n# Create an image with solid colors and save it as a palette-based image\ndef create_image_with_palette_compression_demo():\n    # Image dimensions\n    width, height = 800, 600\n    \n    # Create a new image with a white background\n    image = Image.new('RGB', (width, height), 'white')\n    draw = ImageDraw.Draw(image)\n    \n    # Create rectangles of solid colors\n    colors = ['red', 'green', 'blue', 'yellow', 'black']\n    rectangle_width = width // len(colors)\n    for i, color in enumerate(colors):\n        draw.rectangle([i * rectangle_width, 0, (i + 1) * rectangle_width, height], fill=color)\n    \n    # Convert the image to use a palette (8-bit color)\n    image = image.convert('P', palette=Image.ADAPTIVE, colors=256)\n    \n    # Save the image using PNG format\n    output_path = './tmp/palette_based_compression_demo.png'\n    image.save(output_path, 'PNG')\n\n# Ensure the ./tmp/ folder exists\nimport os\nif not os.path.exists('./tmp/'):\n    os.makedirs('./tmp/')\n\ncreate_image_with_palette_compression_demo()", "sRGB Support": "import numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\n# Ensure the ./tmp/ directory exists\noutput_dir = './tmp/'\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n\n# Create an image with varying brightness\nwidth, height = 256, 256\nimage = np.zeros((height, width, 3), dtype=np.uint8)\n\n# Create a gradient from left (black) to right (white)\n# For sRGB, we use a 3-channel image\nfor x in range(width):\n    color_value = x\n    image[:, x, :] = [color_value, color_value, color_value]  # RGB\n\n# Apply gamma correction for sRGB\ndef srgb_gamma_correction(channel):\n    # Normalize the pixel values\n    channel = channel / 255.0\n    # Apply sRGB gamma correction\n    channel = np.where(channel <= 0.0031308,\n                       channel * 12.92,\n                       1.055 * np.power(channel, 1/2.4) - 0.055)\n    return np.array(channel * 255, dtype='uint8')\n\nimage_srgb_gamma_corrected = np.zeros_like(image)\nfor i in range(3):  # Apply the correction to each channel\n    image_srgb_gamma_corrected[:, :, i] = srgb_gamma_correction(image[:, :, i])\n\n# Save the original and sRGB gamma-corrected images\nplt.imsave(f'{output_dir}original_rgb.png', image)\nplt.imsave(f'{output_dir}srgb_gamma_corrected.png', image_srgb_gamma_corrected)", "Indexed Color Support": "from PIL import Image, ImageDraw, ImagePalette\n\ndef create_indexed_image_with_compression_demo():\n    # Image dimensions\n    width, height = 800, 600\n    \n    # Create a new image with a white background in mode 'P' for palette-based images\n    image = Image.new('P', (width, height), 'white')\n    \n    # Define a palette: each entry consists of three bytes for R, G, and B\n    palette = [\n        255, 255, 255,  # white\n        255, 0, 0,      # red\n        0, 255, 0,      # green\n        0, 0, 255,      # blue\n        255, 255, 0,    # yellow\n        0, 0, 0,        # black\n    ] + [0, 0, 0] * (256 - 6)  # Fill the rest of the 256 color palette with black\n    \n    # Assign palette to the image\n    image.putpalette(palette)\n    \n    # Use ImageDraw to fill rectangles with the colors from the palette\n    draw = ImageDraw.Draw(image)\n    colors = [1, 2, 3, 4, 5]  # Palette indices for our defined colors (0 is white, already the background)\n    rectangle_width = width // len(colors)\n    \n    for i, color_index in enumerate(colors):\n        draw.rectangle([i * rectangle_width, 0, (i + 1) * rectangle_width, height], fill=color_index)\n    \n    # Save the image using PNG format which will automatically use the palette\n    output_path = './tmp/indexed_lossless_compression_demo.png'\n    image.save(output_path, 'PNG')\n\n# Ensure the ./tmp/ folder exists\nimport os\nif not os.path.exists('./tmp/'):\n    os.makedirs('./tmp/')\n\ncreate_indexed_image_with_compression_demo()", "Binary Transparency": "from PIL import Image, PngImagePlugin, ImageDraw\nimport os\nfrom datetime import datetime\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create a new image with palette mode for binary transparency\nimage = Image.new('P', (640, 480), color='white')\n\n# Create a palette with 256 colors, where the first color (index 0) is transparent\npalette = []\nfor i in range(256):\n    if i == 0:\n        palette.extend((255, 255, 255, 0))  # Making the first color fully transparent (RGBA)\n    else:\n        palette.extend((i, i, i))  # Grayscale for the rest\n\n# Ensure the palette is the correct size (768 for RGB)\npalette = palette[:768]\n\nimage.putpalette(palette)\nimage.info['transparency'] = 0  # Setting index 0 as the transparent color\n\n# Draw a simple shape to demonstrate transparency\ndraw = ImageDraw.Draw(image)\ndraw.rectangle([10, 10, 200, 200], fill=1)  # Filling with index 1, which is not transparent\n\n# Prepare metadata\nmeta_info = PngImagePlugin.PngInfo()\nmeta_info.add_text('Copyright', 'Copyright 2023 by Example')\nmeta_info.add_text('Comment', 'Generated for demonstrating binary transparency in PNG files.')\nmeta_info.add_text('Creation Time', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n\n# Save the image with metadata\nimage.save('./tmp/binary_transparency_example.png', 'PNG', pnginfo=meta_info)\n\nprint('Image with binary transparency saved to ./tmp/binary_transparency_example.png')", "Two-dimensional Interlacing (Adam7)": "from PIL import Image, PngImagePlugin, ImageDraw\nimport os\nfrom datetime import datetime\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create a new image with palette mode for binary transparency\nimage = Image.new('P', (640, 480), color='white')\n\n# Create a palette with 256 colors, where the first color (index 0) is transparent\npalette = []\nfor i in range(256):\n    if i == 0:\n        palette.extend((255, 255, 255, 0))  # Making the first color fully transparent (RGBA)\n    else:\n        palette.extend((i, i, i))  # Grayscale for the rest\n\n# Ensure the palette is the correct size (768 for RGB)\npalette = palette[:768]\n\nimage.putpalette(palette)\nimage.info['transparency'] = 0  # Setting index 0 as the transparent color\n\n# Draw a simple shape to demonstrate transparency\ndraw = ImageDraw.Draw(image)\ndraw.rectangle([10, 10, 200, 200], fill=1)  # Filling with index 1, which is not transparent\n\n# Prepare metadata\nmeta_info = PngImagePlugin.PngInfo()\nmeta_info.add_text('Copyright', 'Copyright 2023 by Example')\nmeta_info.add_text('Comment', 'Generated for demonstrating binary transparency and Adam7 interlacing in PNG files.')\nmeta_info.add_text('Creation Time', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n\n# Save the image with metadata and enable Adam7 interlacing\nimage.save('./tmp/binary_transparency_adam7_example.png', 'PNG', pnginfo=meta_info, interlace=1)\n\nprint('Image with binary transparency and Adam7 interlacing saved to ./tmp/binary_transparency_adam7_example.png')", "Custom Chunks": "from PIL import Image, PngImagePlugin, ImageDraw\nimport os\nfrom datetime import datetime\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create a new image with palette mode for binary transparency\nimage = Image.new('P', (640, 480), color='white')\n\n# Create a palette with 256 colors, where the first color (index 0) is transparent\npalette = []\nfor i in range(256):\n    if i == 0:\n        palette.extend((255, 255, 255, 0))  # Making the first color fully transparent (RGBA)\n    else:\n        palette.extend((i, i, i))  # Grayscale for the rest\n\n# Ensure the palette is the correct size (768 for RGB)\npalette = palette[:768]\n\nimage.putpalette(palette)\nimage.info['transparency'] = 0  # Setting index 0 as the transparent color\n\n# Draw a simple shape to demonstrate transparency\ndraw = ImageDraw.Draw(image)\ndraw.rectangle([10, 10, 200, 200], fill=1)  # Filling with index 1, which is not transparent\n\n# Prepare metadata\nmeta_info = PngImagePlugin.PngInfo()\nmeta_info.add_text('Copyright', 'Copyright 2023 by Example')\nmeta_info.add_text('Comment', 'Generated for demonstrating binary transparency and Adam7 interlacing in PNG files.')\nmeta_info.add_text('Creation Time', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n\n# Adding Custom Chunks\n# For this example, let's add a custom chunk named 'zTXT' for demonstration.\n# In reality, custom chunks should avoid names that might conflict with future standard chunks.\n# 'zTXT' is used here purely for demonstration purposes; it's a predefined type but illustrates the method.\n# For truly custom data, consider using 'prIV', 'tEXt', or similar, with a unique keyword.\ncustom_chunk_key = \"zTXt\"\ncustom_chunk_data = \"This is a custom chunk for demonstration.\".encode(\"utf-8\")\nmeta_info.add_text(custom_chunk_key, custom_chunk_data.decode(\"iso-8859-1\"))  # Encoding and decoding to bypass PIL's handling\n\n# Save the image with metadata and enable Adam7 interlacing\nimage.save('./tmp/binary_transparency_adam7_custom_chunk_example.png', 'PNG', pnginfo=meta_info, interlace=1)\n\nprint('Image with binary transparency, Adam7 interlacing, and custom chunk saved to ./tmp/binary_transparency_adam7_custom_chunk_example.png')", "Soft Gamma Curve": "from PIL import Image, PngImagePlugin, ImageDraw\nimport os\nfrom datetime import datetime\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create a new image with palette mode for binary transparency\nimage = Image.new('P', (640, 480), color='white')\n\n# Create a palette with 256 colors, where the first color (index 0) is transparent\npalette = []\nfor i in range(256):\n    if i == 0:\n        palette.extend((255, 255, 255, 0))  # Making the first color fully transparent (RGBA)\n    else:\n        palette.extend((i, i, i))  # Grayscale for the rest\n\n# Ensure the palette is the correct size (768 for RGB)\npalette = palette[:768]\n\nimage.putpalette(palette)\nimage.info['transparency'] = 0  # Setting index 0 as the transparent color\n\n# Draw a simple shape to demonstrate transparency\ndraw = ImageDraw.Draw(image)\ndraw.rectangle([10, 10, 200, 200], fill=1)  # Filling with index 1, which is not transparent\n\n# Prepare metadata\nmeta_info = PngImagePlugin.PngInfo()\nmeta_info.add_text('Copyright', 'Copyright 2023 by Example')\nmeta_info.add_text('Comment', 'Generated for demonstrating binary transparency and soft gamma curve in PNG files.')\nmeta_info.add_text('Creation Time', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n\n# Adding a soft gamma curve. This uses a gAMA chunk with a value of 1/2.2, encoded as an integer.\n# The PNG specification requires the gamma value to be multiplied by 100000 when stored in the file.\n# A gamma of 1/2.2 is approximately 45455 in PNG's integer format.\nmeta_info.add_itxt('gAMA', '45455', zip=False)\n\n# Save the image with metadata\nimage.save('./tmp/binary_transparency_soft_gamma_example.png', 'PNG', pnginfo=meta_info)\n\nprint('Image with binary transparency and soft gamma curve saved to ./tmp/binary_transparency_soft_gamma_example.png')", "Text Compression": "import os\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom PIL import Image, PngImagePlugin\nimport io\n\n# Ensure the ./tmp/ directory exists\noutput_dir = \"./tmp/\"\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n\n# Generate an image to demonstrate PNG's robustness to file corruption\n# Using a basic plot for simplicity\n\n# Creating a simple plot\nplt.figure(figsize=(6, 4))\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\nplt.plot(x, y, label='Sin(x)')\nplt.title('Robustness to File Corruption: PNG Format')\nplt.xlabel('X axis')\nplt.ylabel('Y axis')\nplt.legend()\n\n# Save the plot as a PNG file in memory (not directly to disk)\nbuf = io.BytesIO()\nplt.savefig(buf, format='png')\nplt.close()\n\n# Textual information to add as metadata in PNG\ntext_to_add = \"Text Compression: Textual information within PNG files, like comments and metadata, can be added, reducing the overall file size without affecting the image data.\"\n\n# Use PIL to add text as metadata to the PNG\nbuf.seek(0)  # Go to the start of the in-memory file\nimg = Image.open(buf)\n\n# Create a PngInfo object and add the text information\npnginfo = PngImagePlugin.PngInfo()\npnginfo.add_text(\"Comment\", text_to_add)\n\n# Save the modified image with text information as metadata\noutput_path = os.path.join(output_dir, 'robustness_to_file_corruption_with_compression.png')\nimg.save(output_path, pnginfo=pnginfo)\n\nprint(f\"Image saved at: {output_path}\")", "Robust File Structure": "import os\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom PIL import Image, PngImagePlugin\nimport io\n\n# Ensure the ./tmp/ directory exists\noutput_dir = \"./tmp/\"\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n\n# Generate an image to demonstrate PNG's robustness to file corruption\n# and robust file structure\n# Using a basic plot for simplicity\n\n# Creating a simple plot\nplt.figure(figsize=(6, 4))\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\nplt.plot(x, y, label='Sin(x)')\nplt.title('PNG Features: Robustness and File Structure')\nplt.xlabel('X axis')\nplt.ylabel('Y axis')\nplt.legend()\n\n# Save the plot as a PNG file in memory (not directly to disk)\nbuf = io.BytesIO()\nplt.savefig(buf, format='png')\nplt.close()\n\n# Textual information to add as metadata in PNG for both features\ntext_to_add = \"Text Compression: Textual information within PNG files, like comments and metadata, can be added, reducing the overall file size without affecting the image data.\"\ntext_to_add += \"\\nRobust File Structure: The PNG file structure is designed to be easily recoverable in case of transmission errors, enhancing its reliability for storage and transmission.\"\n\n# Use PIL to add text as metadata to the PNG\nbuf.seek(0)  # Go to the start of the in-memory file\nimg = Image.open(buf)\n\n# Create a PngInfo object and add the text information\npnginfo = PngImagePlugin.PngInfo()\npnginfo.add_text(\"Comment\", text_to_add)\n\n# Save the modified image with text information as metadata\noutput_path = os.path.join(output_dir, 'png_features_robustness_and_file_structure.png')\nimg.save(output_path, pnginfo=pnginfo)\n\nprint(f\"Image saved at: {output_path}\")", "Animation Support (APNG)": "from PIL import Image, PngImagePlugin, ImageDraw, ImageSequence\nimport os\nfrom datetime import datetime\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create multiple frames for the APNG\nframes = []\n\n# Frame generation loop\nfor i in range(10):  # Generate 10 frames for demonstration\n    # Create a new image with palette mode for binary transparency\n    image = Image.new('P', (640, 480), color='white')\n\n    # Create a palette with 256 colors, where the first color (index 0) is transparent\n    palette = []\n    for j in range(256):\n        if j == 0:\n            palette.extend((255, 255, 255, 0))  # Making the first color fully transparent (RGBA)\n        else:\n            palette.extend((j, j, j))  # Grayscale for the rest\n\n    # Ensure the palette is the correct size (768 for RGB)\n    palette = palette[:768]\n\n    image.putpalette(palette)\n    image.info['transparency'] = 0  # Setting index 0 as the transparent color\n\n    # Draw a simple shape to demonstrate transparency, moving with the frame number\n    draw = ImageDraw.Draw(image)\n    draw.rectangle([10+i*10, 10+i*10, 200+i*10, 200+i*10], fill=1)  # Filling with index 1, which is not transparent\n\n    frames.append(image)\n\n# Prepare metadata for the first frame\nmeta_info = PngImagePlugin.PngInfo()\nmeta_info.add_text('Copyright', 'Copyright 2023 by Example')\nmeta_info.add_text('Comment', 'Generated for demonstrating binary transparency, Adam7 interlacing, and APNG animation.')\nmeta_info.add_text('Creation Time', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n\n# Adding Custom Chunks to the first frame\ncustom_chunk_key = \"zTXt\"\ncustom_chunk_data = \"This is a custom chunk for demonstration.\".encode(\"utf-8\")\nmeta_info.add_text(custom_chunk_key, custom_chunk_data.decode(\"iso-8859-1\"))  # Encoding and decoding to bypass PIL's handling\n\n# Save the APNG\nframes[0].save('./tmp/binary_transparency_adam7_custom_chunk_animation_example.png',\n               save_all=True,\n               append_images=frames[1:],\n               loop=0,\n               duration=100,  # Duration of each frame in milliseconds\n               pnginfo=meta_info,\n               interlace=1)\n\nprint('APNG with binary transparency, Adam7 interlacing, custom chunk, and animation saved to ./tmp/binary_transparency_adam7_custom_chunk_animation_example.png')", "Stereoscopic Images": "from PIL import Image, ImageDraw, ImagePalette\n\ndef create_stereoscopic_image_demo():\n    # Image dimensions\n    width, height = 800, 600\n    \n    # Create two new images with a white background in mode 'P' for palette-based images\n    left_image = Image.new('P', (width, height), 'white')\n    right_image = Image.new('P', (width, height), 'white')\n    \n    # Define a palette: each entry consists of three bytes for R, G, and B\n    palette = [\n        255, 255, 255,  # white\n        255, 0, 0,      # red\n        0, 255, 0,      # green\n        0, 0, 255,      # blue\n        255, 255, 0,    # yellow\n        0, 0, 0,        # black\n    ] + [0, 0, 0] * (256 - 6)  # Fill the rest of the 256 color palette with black\n    \n    # Assign palette to both images\n    left_image.putpalette(palette)\n    right_image.putpalette(palette)\n    \n    # Use ImageDraw to fill rectangles with the colors from the palette\n    def draw_rectangles(image, offset=0):\n        draw = ImageDraw.Draw(image)\n        colors = [1, 2, 3, 4, 5]  # Palette indices for our defined colors (0 is white, already the background)\n        rectangle_width = width // len(colors)\n        \n        for i, color_index in enumerate(colors):\n            draw.rectangle([i * rectangle_width + offset, 0, (i + 1) * rectangle_width + offset, height], fill=color_index)\n    \n    # Draw the rectangles on both images with a slight horizontal offset to create the stereoscopic effect\n    draw_rectangles(left_image, -10)\n    draw_rectangles(right_image, 10)\n    \n    # Combine the two images into one stereoscopic image (side by side)\n    stereoscopic_width = width * 2\n    stereoscopic_image = Image.new('P', (stereoscopic_width, height), 'white')\n    stereoscopic_image.paste(left_image, (0, 0))\n    stereoscopic_image.paste(right_image, (width, 0))\n    stereoscopic_image.putpalette(palette)\n    \n    # Save the stereoscopic image using PNG format\n    output_path = './tmp/stereoscopic_demo.png'\n    stereoscopic_image.save(output_path, 'PNG')\n\n# Ensure the ./tmp/ folder exists\nimport os\nif not os.path.exists('./tmp/'):\n    os.makedirs('./tmp/')\n\ncreate_stereoscopic_image_demo()", "Digital Signature": "from PIL import Image, PngImagePlugin, ImageDraw\nimport os\nfrom datetime import datetime\nimport hashlib\nimport base64\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create a new image with palette mode for binary transparency\nimage = Image.new('P', (640, 480), color='white')\n\n# Create a palette with 256 colors, where the first color (index 0) is transparent\npalette = []\nfor i in range(256):\n    if i == 0:\n        palette.extend((255, 255, 255, 0))  # Making the first color fully transparent (RGBA)\n    else:\n        palette.extend((i, i, i))  # Grayscale for the rest\n\n# Ensure the palette is the correct size (768 for RGB)\npalette = palette[:768]\n\nimage.putpalette(palette)\nimage.info['transparency'] = 0  # Setting index 0 as the transparent color\n\n# Draw a simple shape to demonstrate transparency\ndraw = ImageDraw.Draw(image)\ndraw.rectangle([10, 10, 200, 200], fill=1)  # Filling with index 1, which is not transparent\n\n# Prepare metadata\nmeta_info = PngImagePlugin.PngInfo()\nmeta_info.add_text('Copyright', 'Copyright 2023 by Example')\nmeta_info.add_text('Comment', 'Generated for demonstrating binary transparency in PNG files.')\nmeta_info.add_text('Creation Time', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n\n# Digital Signature\n# Simulate generating a digital signature by hashing the image content (you would replace this with your actual signing process)\nimage_bytes = image.tobytes()\nsignature_hash = hashlib.sha256(image_bytes).digest()\nsignature_b64 = base64.b64encode(signature_hash).decode('utf-8')\nmeta_info.add_text('Digital Signature', signature_b64)\n\n# Save the image with metadata\nimage.save('./tmp/binary_transparency_example_with_signature.png', 'PNG', pnginfo=meta_info)\n\nprint('Image with binary transparency and digital signature saved to ./tmp/binary_transparency_example_with_signature.png')", "High Dynamic Range (HDR) Support": "from PIL import Image, ImageDraw\nimport numpy as np\nimport os\n\n# Ensure the ./tmp/ directory exists\nif not os.path.exists('./tmp/'):\n    os.makedirs('./tmp/')\n\n# HDR support in PNG through bit depth and color modes is limited and not natively supported as in formats like HDR or EXR.\n# However, we can simulate a higher dynamic range by manipulating the image's contrast and brightness.\n# For true HDR support, consider converting to a format that supports HDR natively.\n\n# Create an image with transparent background\nwidth, height = 400, 400\nimage = Image.new(\"RGBA\", (width, height), (255, 0, 0, 0))\n\n# Initialize the drawing context\ndraw = ImageDraw.Draw(image)\n\n# Draw a semi-transparent red circle in the center\ncircle_radius = 100\ncircle_center = (width // 2, height // 2)\ndraw.ellipse([circle_center[0] - circle_radius, circle_center[1] - circle_radius,\n              circle_center[0] + circle_radius, circle_center[1] + circle_radius], \n             fill=(255, 0, 0, 128))  # Semi-transparent red\n\n# Convert image to an array for manipulation\nimg_array = np.array(image)\n\n# Manipulate the array to simulate HDR:\n# Increase contrast by scaling the differences from the mean, then clipping to valid range\nmean = np.mean(img_array, axis=(0, 1), keepdims=True)\ncontrast_factor = 1.5  # Adjust this factor to simulate different levels of HDR effect\nimg_array = np.clip((img_array - mean) * contrast_factor + mean, 0, 255).astype(np.uint8)\n\n# Convert back to PIL Image\nhdr_image = Image.fromarray(img_array)\n\n# Save the image with transparency and simulated HDR effect\nhdr_image.save('./tmp/hdr_transparent_circle.png')", "Multiple Layers": "import os\nimport numpy as np\nfrom PIL import Image\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Generate horizontal gradient image\nwidth, height = 256, 256\nbase_layer = np.zeros((height, width, 3), dtype=np.uint8)\n\n# Create gradient for the base layer\nfor x in range(width):\n    for y in range(height):\n        base_layer[y, x] = [x, x, x]  # RGB channels\n\n# Generate an additional layer with a different pattern (for demonstration)\n# This will act as our \"Multiple Layers\" feature\noverlay_layer = np.zeros((height, width, 3), dtype=np.uint8)\n\n# Create an overlay pattern\nfor x in range(width):\n    for y in range(height):\n        overlay_layer[y, x] = [(255-x) // 2, (255-x) // 4, (255-x) // 4]  # Applying a different pattern\n\n# Combine the layers\n# Note: Since PNG does not natively support multiple image layers like PSD files,\n# we simulate this by blending the layers together.\n# For real multi-layer support, consider saving each layer as a separate file or using a format that supports layers.\ncombined_image_data = np.clip(base_layer + overlay_layer, 0, 255).astype(np.uint8)\n\n# Save the combined image\nimg = Image.fromarray(combined_image_data, 'RGB')\nimg.save(f'./tmp/gradient_with_overlay.png', format='PNG', compress_level=9)\n\nprint(\"Image with 'Multiple Layers' saved as 'gradient_with_overlay.png'.\")", "Tile-based Image Viewing": "import os\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom PIL import Image, PngImagePlugin\nimport io\n\n# Ensure the ./tmp/ directory exists\noutput_dir = \"./tmp/\"\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n\n# Generate an image to demonstrate PNG's robustness to file corruption,\n# robust file structure, and tile-based image viewing\n# Using a basic plot for simplicity\n\n# Creating a simple plot\nplt.figure(figsize=(6, 4))\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\nplt.plot(x, y, label='Sin(x)')\nplt.title('PNG Features: Robustness, File Structure, and Tile-based Image Viewing')\nplt.xlabel('X axis')\nplt.ylabel('Y axis')\nplt.legend()\n\n# Save the plot as a PNG file in memory (not directly to disk)\nbuf = io.BytesIO()\nplt.savefig(buf, format='png')\nplt.close()\n\n# Textual information to add as metadata in PNG for features\ntext_to_add = \"Text Compression: Textual information within PNG files, like comments and metadata, can be added, reducing the overall file size without affecting the image data.\"\ntext_to_add += \"\\nRobust File Structure: The PNG file structure is designed to be easily recoverable in case of transmission errors, enhancing its reliability for storage and transmission.\"\ntext_to_add += \"\\nTile-based Image Viewing: Specialized extensions or modifications of PNG support tile-based viewing, enabling efficient viewing and manipulation of very large images by loading only the visible portions.\"\n\n# Use PIL to add text as metadata to the PNG\nbuf.seek(0)  # Go to the start of the in-memory file\nimg = Image.open(buf)\n\n# Create a PngInfo object and add the text information\npnginfo = PngImagePlugin.PngInfo()\npnginfo.add_text(\"Comment\", text_to_add)\n\n# Save the modified image with text information as metadata\noutput_path = os.path.join(output_dir, 'png_features_with_tile_based_viewing.png')\nimg.save(output_path, pnginfo=pnginfo)\n\nprint(f\"Image saved at: {output_path}\")", "Lossy Compression Options": "from PIL import Image, ImageDraw\nimport os\n\n# Create an image with solid colors and save it as a palette-based image with lossy compression\ndef create_image_with_palette_and_lossy_compression_demo():\n    # Image dimensions\n    width, height = 800, 600\n    \n    # Create a new image with a white background\n    image = Image.new('RGB', (width, height), 'white')\n    draw = ImageDraw.Draw(image)\n    \n    # Create rectangles of solid colors\n    colors = ['red', 'green', 'blue', 'yellow', 'black']\n    rectangle_width = width // len(colors)\n    for i, color in enumerate(colors):\n        draw.rectangle([i * rectangle_width, 0, (i + 1) * rectangle_width, height], fill=color)\n    \n    # Convert the image to use a palette (8-bit color)\n    image = image.convert('P', palette=Image.ADAPTIVE, colors=256)\n    \n    # Before saving, apply a lossy compression technique\n    # This example uses PIL's 'optimize' and 'save_all' parameters for demonstration,\n    # which are not truly lossy but can help reduce file size in some cases.\n    # For actual lossy compression, consider using an external tool or library that supports PNG lossy compression.\n    output_path = './tmp/palette_lossy_compression_demo.png'\n    image.save(output_path, 'PNG', optimize=True, save_all=True)\n\n# Ensure the ./tmp/ folder exists\nif not os.path.exists('./tmp/'):\n    os.makedirs('./tmp/')\n\ncreate_image_with_palette_and_lossy_compression_demo()", "Chunk Ordering": "from PIL import Image, PngImagePlugin, ImageDraw, PngImagePlugin\nimport os\nfrom datetime import datetime\n\n# Ensure the ./tmp/ directory exists\nos.makedirs('./tmp/', exist_ok=True)\n\n# Create a new image with palette mode for binary transparency\nimage = Image.new('P', (640, 480), color='white')\n\n# Create a palette with 256 colors, where the first color (index 0) is transparent\npalette = []\nfor i in range(256):\n    if i == 0:\n        palette.extend((255, 255, 255, 0))  # Making the first color fully transparent (RGBA)\n    else:\n        palette.extend((i, i, i))  # Grayscale for the rest\n\n# Ensure the palette is the correct size (768 for RGB)\npalette = palette[:768]\n\nimage.putpalette(palette)\nimage.info['transparency'] = 0  # Setting index 0 as the transparent color\n\n# Draw a simple shape to demonstrate transparency\ndraw = ImageDraw.Draw(image)\ndraw.rectangle([10, 10, 200, 200], fill=1)  # Filling with index 1, which is not transparent\n\n# Prepare metadata\nmeta_info = PngImagePlugin.PngInfo()\nmeta_info.add_text('Copyright', 'Copyright 2023 by Example')\nmeta_info.add_text('Comment', 'Generated for demonstrating binary transparency, Adam7 interlacing, and chunk ordering in PNG files.')\nmeta_info.add_text('Creation Time', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n\n# Save the image with metadata and enable Adam7 interlacing\n# The PNG spec does not allow direct control of chunk ordering via the PIL API,\n# but you can optimize loading times by how you structure and save the file.\n# For instance, saving critical chunks (like IHDR, PLTE, tRNS, IDAT) first, is handled by PIL itself.\n# We ensure metadata is added before saving which optimizes chunk order indirectly.\n\n# To further demonstrate an example of 'Chunk Ordering' conceptually,\n# note that PIL handles critical chunks efficiently by default, but does not provide\n# an explicit interface for manual chunk reordering. The following save operation\n# already benefits from PIL's internal handling of chunk ordering for optimization.\nimage.save('./tmp/binary_transparency_adam7_chunk_ordering_example.png', 'PNG', pnginfo=meta_info, interlace=1)\n\nprint('Image with binary transparency, Adam7 interlacing, and chunk ordering saved to ./tmp/binary_transparency_adam7_chunk_ordering_example.png')", "Error Correction Codes": "import numpy as np\nimport matplotlib.pyplot as plt\nimport os\nimport qrcode  # For generating QR code which includes error correction capability\n\n# Ensure the ./tmp/ directory exists\noutput_dir = './tmp/'\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n\n# Create an image with varying brightness\nwidth, height = 256, 256\nimage = np.zeros((height, width, 3), dtype=np.uint8)\n\n# Create a gradient from left (black) to right (white)\n# For sRGB, we use a 3-channel image\nfor x in range(width):\n    color_value = x\n    image[:, x, :] = [color_value, color_value, color_value]  # RGB\n\n# Apply gamma correction for sRGB\ndef srgb_gamma_correction(channel):\n    # Normalize the pixel values\n    channel = channel / 255.0\n    # Apply sRGB gamma correction\n    channel = np.where(channel <= 0.0031308,\n                       channel * 12.92,\n                       1.055 * np.power(channel, 1/2.4) - 0.055)\n    return np.array(channel * 255, dtype='uint8')\n\nimage_srgb_gamma_corrected = np.zeros_like(image)\nfor i in range(3):  # Apply the correction to each channel\n    image_srgb_gamma_corrected[:, :, i] = srgb_gamma_correction(image[:, :, i])\n\n# Save the original and sRGB gamma-corrected images\nplt.imsave(f'{output_dir}original_rgb.png', image)\nplt.imsave(f'{output_dir}srgb_gamma_corrected.png', image_srgb_gamma_corrected)\n\n# Generating a QR code with error correction capability for data integrity\nqr = qrcode.QRCode(\n    version=1,\n    error_correction=qrcode.constants.ERROR_CORRECT_H,  # High error correction\n    box_size=10,\n    border=4,\n)\nqr.add_data('Error Correction Codes feature included')\nqr.make(fit=True)\n\n# Convert QR code to an image\nimg_qr = qr.make_image(fill_color=\"black\", back_color=\"white\")\nqr_code_path = f'{output_dir}error_correction_codes_qr.png'\nimg_qr.save(qr_code_path)\n\nprint(f\"Original and sRGB gamma-corrected images saved in {output_dir}\")\nprint(f\"QR code with Error Correction Codes feature saved as {qr_code_path}\")", "Embedded ICC Profiles Version 4": "import os\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom PIL import Image, PngImagePlugin, ImageCms\nimport io\n\n# Ensure the ./tmp/ directory exists\noutput_dir = \"./tmp/\"\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n\n# Generate an image to demonstrate PNG's robustness to file corruption,\n# robust file structure, and the inclusion of Embedded ICC Profiles Version 4\n# Using a basic plot for simplicity\n\n# Creating a simple plot\nplt.figure(figsize=(6, 4))\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\nplt.plot(x, y, label='Sin(x)')\nplt.title('PNG Features: Robustness, File Structure, and ICC Profiles')\nplt.xlabel('X axis')\nplt.ylabel('Y axis')\nplt.legend()\n\n# Save the plot as a PNG file in memory (not directly to disk)\nbuf = io.BytesIO()\nplt.savefig(buf, format='png')\nplt.close()\n\n# Textual information to add as metadata in PNG for features\ntext_to_add = \"Text Compression: Textual information within PNG files, like comments and metadata, can be added, reducing the overall file size without affecting the image data.\"\ntext_to_add += \"\\nRobust File Structure: The PNG file structure is designed to be easily recoverable in case of transmission errors, enhancing its reliability for storage and transmission.\"\ntext_to_add += \"\\nEmbedded ICC Profiles Version 4: While PNG inherently supports color management through ICC profiles, newer versions of these profiles offer improved accuracy and compatibility across different devices.\"\n\n# Use PIL to add text as metadata to the PNG\nbuf.seek(0)  # Go to the start of the in-memory file\nimg = Image.open(buf)\n\n# Create a PngInfo object and add the text information\npnginfo = PngImagePlugin.PngInfo()\npnginfo.add_text(\"Comment\", text_to_add)\n\n# To add an ICC profile, we first need to create or load an ICC profile\n# For demonstration, we'll convert the image to sRGB, which is a common use case\n# Note: This assumes the image is not already in sRGB and does not embed an actual ICC v4 profile\n# To use a specific ICC v4 profile, you would load it from disk instead\nsrgb_profile = ImageCms.createProfile(\"sRGB\")\nimg = ImageCms.profileToProfile(img, srgb_profile, srgb_profile, outputMode='RGB')\n\n# Save the modified image with text information and an ICC profile as metadata\noutput_path = os.path.join(output_dir, 'png_features_robustness_file_structure_icc_v4.png')\nimg.save(output_path, pnginfo=pnginfo)\n\nprint(f\"Image saved at: {output_path}\")", "Variable Opacity of Pixels": "from PIL import Image, ImageDraw\n\ndef create_image_with_variable_opacity():\n    # Image dimensions\n    width, height = 800, 600\n    \n    # Create a new image with a white background and alpha channel for opacity\n    image = Image.new('RGBA', (width, height), (255, 255, 255, 255))\n    draw = ImageDraw.Draw(image)\n    \n    # Create rectangles of solid colors with varying opacity\n    colors = [\n        ('red', 255), # Opaque red\n        ('green', 200), # Semi-transparent green\n        ('blue', 150), # More transparent blue\n        ('yellow', 100), # Very transparent yellow\n        ('black', 50) # Nearly transparent black\n    ]\n    rectangle_width = width // len(colors)\n    for i, (color, opacity) in enumerate(colors):\n        # Convert color names to RGB and add opacity\n        rgb_color = Image.new('RGBA', (1, 1), color).load()[0, 0][:3] + (opacity,)\n        draw.rectangle([i * rectangle_width, 0, (i + 1) * rectangle_width, height], fill=rgb_color)\n    \n    # Save the image using PNG format to support opacity\n    output_path = './tmp/variable_opacity_demo.png'\n    image.save(output_path, 'PNG')\n\n# Ensure the ./tmp/ folder exists\nimport os\nif not os.path.exists('./tmp/'):\n    os.makedirs('./tmp/')\n\ncreate_image_with_variable_opacity()"}